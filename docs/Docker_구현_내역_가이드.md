# 🐳 Docker 구현 내역 완전 가이드

**작성일**: 2025년 1월  
**버전**: 2.0.0 (MCP 서버 통합 버전)
**목적**: 프로젝트의 Docker 구현 내역과 이해 방법, 사용 이유 설명

> **✅ MCP 서버 통합 완료**: 모든 주요 기능이 MCP 서버로 제공되며, Docker 이미지에도 포함됩니다.

---

## 📋 목차

1. [Docker 구현 개요](#docker-구현-개요) - 초등학생도 이해하는 설명!
2. [현재 구현 상태](#현재-구현-상태)
3. [Docker를 사용한 이유](#docker를-사용한-이유) - 왜 사용하는지 쉽게 설명!
4. [구조 이해하기](#구조-이해하기) - 레고 비유로 설명!
5. [GUI에서 확인하는 방법](#gui에서-확인하는-방법) - 웹 화면에서 확인하기!
6. [Docker 사용 방법](#docker-사용-방법-초등학생도-할-수-있어요) - 실제로 사용하는 방법!
7. [상세 구현 내역](#상세-구현-내역)

---

## 🎯 한눈에 보는 Docker 요약 (30초 이해하기!)

**Docker가 뭔가요?**
- **음식점 프랜차이즈 매뉴얼**이라고 생각하세요!
- 매뉴얼만 있으면 어디서든 똑같은 가게를 만들 수 있어요!

**컨테이너가 뭔가요?**
- **프랜차이즈의 각 가게**라고 생각하세요!
- 우리 프로젝트는 4개 가게를 운영해요:
  1. Frontend 가게 (5173번 주소) - 손님이 보는 곳
  2. Backend 가게 (3001번 주소) - 실제 일을 처리하는 곳 (MCP 서버 통합)
  3. Python MCP 가게 (내부) - AI와 대화하는 곳 (에러 로그, SQL 쿼리, 영향도 분석)
  4. Python HTTP 가게 (3002번 주소) - 화면을 확인하는 곳

**왜 사용하나요?**
- ❌ Docker 없이: 각 컴퓨터마다 설치 방법이 달라서 "내 컴퓨터에서는 되는데..." 문제 발생!
- ✅ Docker 사용: 매뉴얼만 있으면 어디서든 똑같이 작동
**어떻게 사용하나요?**
```bash
# 가게 열기
docker-compose up -d

# 가게 닫기
docker-compose down

# 가게 다시 열기 (문제 해결)
docker-compose restart

# 가게 상태 확인
docker ps
```

**비유로 정리:**
- Docker = 프랜차이즈 본사 (가게를 만드는 회사)
- Dockerfile = 각 가게를 만드는 매뉴얼
- docker-compose.yml = 전체 가게 운영 매뉴얼
- 컨테이너 = 실제로 운영되는 가게
- `docker-compose up -d` = "매뉴얼대로 4개 가게를 모두 열어줘!"

---

## 🐳 Docker 구현 개요

### 초등학생도 이해하는 Docker 설명

**Docker는 뭘까요? - 음식점 비유로 완전히 이해하기!**

Docker를 **음식점 프랜차이즈**라고 생각해보세요!

#### 🍕 실제 예시: 피자집을 열고 싶어요!

**일반적인 방법 (Docker 없이):**

```
상황: 친구와 함께 피자집을 열고 싶어요!

1. 내 컴퓨터에서 피자집 만들기:
   - Node.js 설치 (피자 오븐 설치)
   - Python 설치 (토핑 준비 도구 설치)
   - 데이터베이스 설치 (재료 창고 설치)
   - 환경 변수 설정 (레시피 작성)
   - 모든 것을 하나하나 설치하고 설정함
   - 시간: 3시간 소요

2. 친구 컴퓨터에서도 똑같이 만들기:
   - 친구 컴퓨터에 가서
   - "Node.js 버전이 달라요!" 오류 발생
   - "Python이 없어요!" 오류 발생
   - "환경 변수가 달라요!" 오류 발생
   - 다시 처음부터 설치해야 함
   - 시간: 또 3시간 소요
   - 결과: "내 컴퓨터에서는 되는데..." 문제 발생!

3. 서버에 배포하기:
   - 서버에 가서 또 처음부터 설치
   - 서버 환경이 달라서 또 오류 발생
   - 시간: 또 3시간 소요
   - 결과: 개발 환경과 서버 환경이 달라서 문제 발생!
```

**Docker 방법 (프랜차이즈처럼!):**

```
상황: 피자집 프랜차이즈를 만들었어요!

1. Docker로 피자집 만들기:
   - Dockerfile 작성 (프랜차이즈 매뉴얼 작성)
     → "피자집을 만드는 방법"을 종이에 적어둠
   - docker-compose.yml 작성 (전체 가게 운영 매뉴얼)
     → "4개 가게를 어떻게 운영할지" 적어둠
   - 한 번만 작성하면 끝!

2. 어디서든 똑같이 만들기:
   - 내 컴퓨터: docker-compose up -d
     → 매뉴얼대로 자동으로 피자집 4개가 만들어짐!
   - 친구 컴퓨터: docker-compose up -d
     → 똑같은 매뉴얼로 똑같은 피자집 4개가 만들어짐!
   - 서버: docker-compose up -d
     → 똑같은 매뉴얼로 똑같은 피자집 4개가 만들어짐!
   - 시간: 각각 5분만 소요!
   - 결과: "어디서든 똑같이 작동!" 보장!

3. 장점:
   - 매뉴얼만 있으면 누구나 똑같이 만들 수 있음
   - 환경이 달라도 문제 없음
   - 빠르고 쉬움!
```

**컨테이너는 뭘까요? - 음식점의 각 가게!**

컨테이너는 **프랜차이즈의 각 가게**라고 생각하세요!

```
실제 예시: 우리 프로젝트는 4개 가게를 운영해요!

1. Frontend 가게 (5173번 주소):
   - 손님이 보는 앞쪽 가게
   - 웹사이트 화면을 보여주는 곳
   - 독립적으로 작동함
   - 이 가게가 망가져도 다른 가게는 괜찮음

2. Backend 가게 (3001번 주소):
   - 실제 일을 처리하는 주방
   - 데이터를 저장하고 가져오는 곳
   - ✅ MCP 서버 통합: 뉴스 검색 등 주요 기능을 MCP 서버를 통해 제공
   - 독립적으로 작동함
   - 이 가게가 망가져도 다른 가게는 괜찮음

3. Python MCP 가게 (내부):
   - AI와 대화하는 특별한 가게
   - 에러 로그 분석, SQL 쿼리 분석, 영향도 분석 등 제공
   - 밖에서는 못 봄 (내부 통신만)
   - 독립적으로 작동함

4. Python HTTP 가게 (3002번 주소):
   - 화면을 확인하는 검수 가게
   - 독립적으로 작동함

각 가게(컨테이너)는:
- 독립적으로 작동함 (한 가게가 망가져도 다른 가게는 괜찮음)
- 가게 안에 필요한 모든 것이 들어있음 (직원, 도구, 재료)
- 가게를 쉽게 옮기고 복사할 수 있음 (다른 곳에 똑같은 가게 만들기)
- 가게를 쉽게 부수고 다시 만들 수 있음 (문제 생기면 새로 만들기)
```

**왜 Docker를 사용하나요? - 실제 상황으로 이해하기!**

#### 1. **"내 컴퓨터에서는 되는데..." 문제 해결**

**실제 상황:**
```
상황: 친구와 함께 프로젝트를 만들었어요!

❌ Docker 없이:
- 내 컴퓨터: Node.js 20 버전 설치됨 → 잘 작동함 ✅
- 친구 컴퓨터: Node.js 18 버전만 있음 → 오류 발생! ❌
- 결과: "내 컴퓨터에서는 되는데 왜 안 되지?" 문제 발생!

✅ Docker 사용:
- 내 컴퓨터: docker-compose up -d → 잘 작동함 ✅
- 친구 컴퓨터: docker-compose up -d → 똑같이 잘 작동함 ✅
- 이유: Docker가 Node.js 20을 자동으로 설치해줌!
- 결과: "어디서든 똑같이 작동!" 보장!
```

**비유:**
- 프랜차이즈 매뉴얼이 있으면, 어떤 주방에서도 똑같은 피자를 만들 수 있어요!
- 매뉴얼에 "오븐 온도 200도"라고 적혀있으면, 어떤 오븐을 쓰든 200도로 맞춰요!

#### 2. **쉬운 설치 - 한 번의 명령어로 끝!**

**실제 상황:**
```
상황: 새 컴퓨터에서 프로젝트를 실행하고 싶어요!

❌ Docker 없이:
1. Node.js 설치 (10분)
2. Python 설치 (10분)
3. 데이터베이스 설치 (20분)
4. 환경 변수 설정 (30분)
5. 각종 라이브러리 설치 (30분)
6. 설정 파일 수정 (20분)
총 시간: 2시간 이상 소요! 😫

✅ Docker 사용:
1. docker-compose up -d (한 번의 명령어!)
총 시간: 5분! 😊

비유:
- 프랜차이즈 매뉴얼만 있으면, 가게를 바로 열 수 있어요!
- 매뉴얼에 "이렇게 하면 피자집이 만들어져요"라고 적혀있으니까요!
```

#### 3. **깔끔한 정리 - 각각 독립적으로 작동!**

**실제 상황:**
```
상황: 여러 프로젝트를 동시에 실행하고 싶어요!

❌ Docker 없이:
- 프로젝트 A: 포트 3000 사용
- 프로젝트 B: 포트 3000 사용
- 결과: 포트 충돌! 둘 다 실행 안 됨! ❌
- "어떤 프로젝트가 포트를 쓰고 있지?" 찾아야 함
- 복잡하고 헷갈림!

✅ Docker 사용:
- 프로젝트 A: 각각 독립된 컨테이너에서 실행
- 프로젝트 B: 각각 독립된 컨테이너에서 실행
- 결과: 서로 방해하지 않음! 둘 다 잘 작동함! ✅
- 각 프로젝트가 독립된 가게처럼 작동함!

비유:
- 프랜차이즈 가게들은 각각 독립적으로 운영돼요!
- 한 가게가 망가져도 다른 가게는 괜찮아요!
- 각 가게는 자신만의 주소(포트)를 가지고 있어요!
```

### 프로젝트에서 Docker가 하는 일 - 실제로 뭘 하나요?

이 프로젝트는 **4개의 서비스를 Docker 컨테이너로 실행**합니다:

**실제 예시: 웹사이트를 만드는 과정**

```
1. Frontend (5173번 주소) - 손님이 보는 가게 앞
   - 역할: 웹사이트 화면을 보여줌
   - 예시: 네이버, 구글 같은 웹사이트 화면
   - 사용자가 브라우저에서 http://localhost:5173 접속하면 이게 작동함!

2. Backend (3001번 주소) - 실제 일을 처리하는 주방
   - 역할: 데이터를 저장하고 가져옴
   - 예시: 사용자가 로그인하면, 여기서 확인하고 저장함
   - Frontend가 "사용자 정보 좀 줘!"라고 요청하면 여기서 처리함!
   - ✅ MCP 서버 통합: 뉴스 검색 등 주요 기능을 MCP 서버를 통해 제공
   - MCP 서버 파일 포함 (`mcp-server.js`)

3. Python MCP (내부) - AI와 대화하는 특별한 가게
   - 역할: AI와 대화하는 서버
   - 예시: ChatGPT 같은 AI와 대화할 때 사용함
   - 밖에서는 못 봄 (보안을 위해 내부 통신만 함)
   - ✅ 모든 Python MCP 서버 포함:
     - 에러 로그 분석 (`mcp-error-log-analyzer.py`)
     - SQL 쿼리 분석 (`mcp-sql-query-analyzer.py`)
     - 영향도 분석 (`mcp-impact-analyzer.py`)
     - 도서 추천 (`mcp-unified-server.py`)
     - 화면 검증 (`mcp-screen-validator-http-server.py`)

4. Python HTTP (3002번 주소) - 화면을 확인하는 검수원
   - 역할: 웹사이트 화면이 제대로 나오는지 확인함
   - 예시: 웹사이트가 깨져있는지 확인하는 도구
```

**비유로 정리하면:**
- Frontend = 가게 앞 (손님이 보는 곳) - 웹사이트 화면
- Backend = 주방 (음식을 만드는 곳) - 데이터 처리
- Python MCP = 창고 관리자 (물건을 찾아주는 사람) - AI 통신
- Python HTTP = 검수원 (품질을 확인하는 사람) - 화면 검증

### Docker의 역할

```
일반 실행 방식:
- 각 서버를 개별적으로 실행
- 환경 설정이 복잡함
- 다른 컴퓨터에서 실행 시 문제 발생 가능
- "내 컴퓨터에서는 되는데..." 문제 발생

Docker 실행 방식:
- 모든 서버를 컨테이너로 패키징
- 한 번의 명령어로 모든 서버 실행
- 어디서든 동일하게 작동
- "어디서든 똑같이 작동" 보장!
```

---

## 📊 현재 구현 상태

### 구현된 Docker 파일들

#### 1. Dockerfile 파일들

**프로덕션 환경:**
- `Dockerfile.frontend` - 프론트엔드 프로덕션 빌드
- `Dockerfile.backend` - 백엔드 프로덕션 빌드
- `Dockerfile.python` - Python 서버 빌드

**개발 환경:**
- `Dockerfile.frontend.dev` - 프론트엔드 개발 빌드 (핫 리로드)
- `Dockerfile.backend.dev` - 백엔드 개발 빌드 (자동 재시작)

#### 2. Docker Compose 파일들

- `docker-compose.yml` - 프로덕션 환경 설정
- `docker-compose.dev.yml` - 개발 환경 설정

#### 3. 빌드 스크립트들

**Windows:**
- `scripts/docker-build.bat` - Docker 이미지 빌드
- `scripts/docker-build-test.bat` - 캐시 없이 빌드
- `scripts/docker-deploy.bat` - 배포 스크립트

**Linux/macOS:**
- `scripts/docker-build.sh` - Docker 이미지 빌드
- `scripts/docker-build-test.sh` - 캐시 없이 빌드
- `scripts/docker-deploy.sh` - 배포 스크립트

#### 4. 설정 파일들

- `.dockerignore` - Docker 빌드 시 제외할 파일 목록
- `docker/nginx.conf` - Nginx 웹 서버 설정

### 서비스 구성

| 서비스 | 포트 | 설명 | 상태 |
|--------|------|------|------|
| Frontend | 5173 | Vue.js 웹 애플리케이션 | ✅ 구현됨 |
| Backend | 3001 | Node.js API 서버 (MCP 서버 통합) | ✅ 구현됨 |
| Python MCP | 내부 | 모든 Python MCP 서버 포함 | ✅ 구현됨 |
| Python HTTP | 3002 | 화면 검증 서버 | ✅ 구현됨 |

**MCP 서버 통합 상태:**
- ✅ Backend: `mcp-server.js` 포함 (뉴스 검색 등)
- ✅ Python MCP: 모든 Python MCP 서버 포함 (에러 로그, SQL 쿼리, 영향도 분석 등)

---

## 🤔 Docker를 사용한 이유 (초등학생도 이해하는 설명)

### 1. 환경 일관성 보장 (모든 곳에서 똑같이 작동)

**문제:**
- 개발자의 컴퓨터마다 Node.js, Python 버전이 다름
- "내 컴퓨터에서는 되는데..." 문제 발생
- 배포 서버 환경이 개발 환경과 다름

**비유:**
- 친구 A는 레고 1세대를 가지고 있음
- 친구 B는 레고 2세대를 가지고 있음
- 같은 설계도로 만들었는데 결과가 다름!
- "우리 집에서는 되는데..." 문제 발생

**해결:**
- Docker 컨테이너에 Node.js 20, Python 3.11 고정
- 모든 환경에서 동일한 버전 사용
- 개발 환경 = 프로덕션 환경
- 마치 모든 사람이 같은 레고 세트를 사용하는 것처럼!

### 2. 쉬운 배포 (한 번의 명령어로 모든 것 실행)

**문제:**
- 서버에 Node.js, Python, Nginx 설치 필요
- 환경 변수 설정 복잡
- 여러 서버를 수동으로 관리

**비유:**
- 레고로 집을 만들려면:
  - 블록 하나하나 찾아서 조립해야 함
  - 시간이 오래 걸림
  - 실수하기 쉬움

**해결:**
- `docker-compose up -d` 한 번으로 모든 서버 실행
- 환경 변수는 `.env` 파일로 관리
- 서버 추가/제거가 쉬움
- 마치 레고 상자 하나를 열면 자동으로 집이 만들어지는 것처럼!

### 3. 격리된 실행 환경 (각각 독립적으로 작동)

**문제:**
- 여러 프로젝트가 같은 포트 사용 시 충돌
- 시스템 라이브러리 버전 충돌
- 프로젝트 간 의존성 충돌

**비유:**
- 여러 사람이 같은 방에서 놀면:
  - 장난감을 서로 뺏어서 싸움 발생
  - "이건 내 거야!" 문제 발생
  - 한 사람이 실수하면 모두 영향받음

**해결:**
- 각 컨테이너가 독립적으로 실행
- 포트 충돌 없음
- 시스템에 영향 없음
- 마치 각자 방에서 놀면 서로 방해하지 않는 것처럼!

### 4. 확장성 (쉽게 늘릴 수 있음)

**문제:**
- 트래픽 증가 시 서버 추가가 어려움
- 로드 밸런싱 설정 복잡

**비유:**
- 가게에 손님이 많아지면:
  - 직원을 더 고용해야 함
  - 하지만 고용하는 게 복잡하고 어려움
  - "어떻게 하지?" 고민

**해결:**
- 컨테이너를 쉽게 복제 가능
- Docker Swarm 또는 Kubernetes로 확장 가능
- 로드 밸런싱 자동화
- 마치 레고 집을 복사해서 여러 개 만들 수 있는 것처럼!

### 5. 개발 효율성 (빠르게 시작할 수 있음)

**문제:**
- 새 개발자가 프로젝트 설정하는 데 시간 소요
- 환경 설정 문서가 복잡함

**비유:**
- 새 친구가 레고 놀이에 참여하려면:
  - 어떤 블록이 필요한지 설명해야 함
  - 블록을 하나하나 찾아야 함
  - 시간이 오래 걸림
  - "이거 어떻게 하는 거야?" 질문 많음

**해결:**
- `docker-compose up` 한 번으로 모든 환경 준비
- 새 개발자도 즉시 개발 시작 가능
- 환경 설정 문서 불필요
- 마치 레고 상자 하나만 주면 바로 시작할 수 있는 것처럼!

---

## 🏗️ 구조 이해하기

### Docker Compose 구조

```yaml
# docker-compose.yml 예시
services:
  frontend:          # 서비스 이름
    build:           # 이미지 빌드 설정
      context: .     # 빌드 컨텍스트 (현재 디렉토리)
      dockerfile: Dockerfile.frontend  # 사용할 Dockerfile
    ports:           # 포트 매핑
      - "5173:80"    # 호스트:컨테이너
    depends_on:      # 의존성 (backend가 먼저 시작)
      - backend
    networks:        # 네트워크 설정
      - test02-network
```

### 멀티 스테이지 빌드 (Frontend) - 두 번에 나눠서 만들기

**멀티 스테이지 빌드는 뭘까요?**

**레고로 집을 만드는 과정**이라고 생각하세요!

```dockerfile
# 1단계: 빌드 스테이지 (작업장에서 만들기)
FROM node:20-alpine AS builder
# - 작업장에서 레고 집을 만듦
# - 필요한 도구(레고 블록)를 모두 사용
# - 완성된 집(dist 폴더)을 만듦

# 2단계: 프로덕션 스테이지 (실제 집에 옮기기)
FROM nginx:alpine
# - 완성된 집만 가져옴
# - 작업 도구는 버림 (필요 없으니까!)
# - 작은 상자에 집만 넣어서 가져감
# - 최종 이미지 크기 최소화 (가볍게!)
```

**왜 이렇게 하나요?**
- 작업 도구(빌드 도구)는 집을 만들 때만 필요함
- 완성된 집만 가져가면 됨
- 상자가 작아져서 가볍고 빠름!
- 마치 레고 집을 만들 때는 많은 도구가 필요하지만, 완성된 집만 가져가면 되는 것처럼!

### 볼륨 마운트 (개발 환경) - 실시간으로 연결하기

**볼륨 마운트는 뭘까요?**

**거울**이라고 생각하세요!

```yaml
volumes:
  - ./src:/app/src  # 내 컴퓨터의 src 폴더를 컨테이너의 src 폴더와 연결
# - 코드 변경 시 자동 반영 (핫 리로드)
```

**비유로 설명하면:**
- 내 컴퓨터의 파일을 수정하면
- 컨테이너 안의 파일도 자동으로 바뀜
- 마치 거울을 보면 내가 움직이면 거울 속 나도 움직이는 것처럼!
- 개발할 때 코드를 수정하면 바로 반영됨 (핫 리로드)

### 네트워크 통신 (집들 사이의 길)

**네트워크는 뭘까요?**

**집들 사이를 연결하는 길**이라고 생각하세요!

```
Frontend (5173) → Backend (3001)
                ↓
         test02-network (Docker 네트워크 = 집들 사이의 길)
                ↓
         Backend → Python MCP (내부 통신 = 뒷문으로 통신)
```

**비유로 설명하면:**
- Frontend (앞집)에서 Backend (뒷집)로 가려면
- test02-network (길)을 따라가면 됨
- Python MCP는 뒷문으로만 통신 (밖에서는 못 봄)
- 마치 마을에 있는 집들이 길로 연결되어 있는 것처럼!

---

## 🖥️ GUI에서 확인하는 방법

### 방법 1: 웹 UI에서 확인 (권장)

**사용자 관리 화면 → Docker 상태 탭**

1. 웹사이트에 로그인
2. "사용자 관리하기" 버튼 클릭
3. "🐳 Docker 상태" 탭 선택
4. 다음 정보 확인:
   - 컨테이너 실행 상태
   - 각 서비스의 상태 (실행 중/중지됨)
   - 포트 매핑 정보
   - 리소스 사용량 (CPU, 메모리)
   - 로그 확인

### 방법 2: Docker Desktop 사용 (레고 상자 관리 프로그램)

**Docker Desktop은 뭘까요?**

**레고 상자를 관리하는 프로그램**이라고 생각하세요!

**설치:**
- https://www.docker.com/products/docker-desktop
- 마치 레고 상자를 사는 것처럼!

**확인 방법:**

1. **Docker Desktop 실행**
   - 레고 상자 관리 프로그램을 여는 것처럼!

2. **"Containers" 탭에서 실행 중인 컨테이너 확인**
   - 지어져 있는 레고 집 목록을 보는 것처럼!

3. **각 컨테이너 클릭하여 상세 정보 확인:**
   - **로그 (Logs)**: 집에서 무슨 일이 일어나는지 일기 보기
   - **리소스 사용량 (Stats)**: 집이 얼마나 공간을 쓰는지 확인
   - **환경 변수 (Inspect)**: 집의 설정 확인

**비유:**
- Docker Desktop = 레고 상자 관리 프로그램
- Containers = 지어져 있는 집 목록
- Logs = 집에서 일어나는 일의 기록
- Stats = 집이 사용하는 공간
- Inspect = 집의 상세 정보

### 방법 3: 터미널 명령어 (고급 사용자용)

**터미널 명령어는 뭘까요?**

**레고 상자를 조작하는 마법 주문**이라고 생각하세요!

```bash
# 실행 중인 컨테이너 확인 (지어져 있는 집 보기)
docker ps
# → "어떤 집이 지어져 있나요?" 물어보기

# 모든 컨테이너 확인 (중지된 것 포함) - 모든 집 보기
docker ps -a
# → "지어졌던 집도 포함해서 모든 집 보기"

# 특정 컨테이너 로그 확인 (집에서 무슨 일이 일어나는지 보기)
docker logs test02-frontend
docker logs test02-backend
# → "앞집에서 무슨 일이 일어났나요?" 물어보기

# 컨테이너 리소스 사용량 확인 (집이 얼마나 공간 쓰는지 보기)
docker stats
# → "각 집이 얼마나 공간을 쓰고 있나요?" 물어보기

# 컨테이너 상세 정보 확인 (집의 상세 정보 보기)
docker inspect test02-frontend
# → "앞집의 자세한 정보를 알려주세요" 물어보기
```

**비유:**
- `docker ps` = "지어져 있는 집 목록 보여줘"
- `docker ps -a` = "지어졌던 집도 포함해서 모든 집 보여줘"
- `docker logs` = "이 집에서 무슨 일이 일어났는지 일기 보여줘"
- `docker stats` = "각 집이 얼마나 공간을 쓰는지 보여줘"
- `docker inspect` = "이 집의 자세한 정보 보여줘"

---

## 🎮 Docker 사용 방법 (초등학생도 할 수 있어요!)

### 현재 화면에서 보이는 것의 의미

**화면에 보이는 정보:**

1. **설치 여부: ✅ 설치됨**
   - Docker가 컴퓨터에 설치되어 있다는 뜻
   - 마치 레고 상자가 집에 있다는 것처럼!

2. **버전: 28.5.2**
   - Docker의 버전 번호
   - 마치 레고 상자에 "2024년 버전"이라고 써있는 것처럼!

3. **실행 상태: ⏸️ 중지됨**
   - 현재 컨테이너(레고 집)가 실행되지 않고 있다는 뜻
   - 마치 레고 집 설계도는 있지만 아직 안 지어졌다는 것처럼!

4. **실행 중인 컨테이너가 없습니다**
   - 지어져 있는 집이 하나도 없다는 뜻
   - 집을 지어야 사용할 수 있어요!

### 컨테이너 시작하기 (가게 열기) - 단계별로 완전히 이해하기!

**현재 상태:**
- Docker 설치됨 ✅ (프랜차이즈 본사가 준비됨)
- 컨테이너 중지됨 ⏸️ (가게들이 아직 안 열림)

**가게를 여는 방법 - 실제로 뭘 하나요?**

#### 단계 1: 명령어 입력하기

```bash
# 모든 가게를 한 번에 열기
docker-compose up -d
```

**이 명령어를 입력하면 무슨 일이 일어날까요?**

```
실제로 일어나는 일:

1. Docker가 docker-compose.yml 파일을 읽음
   → "아, 4개 가게를 열어야 하는구나!" 이해함

2. 각 가게를 순서대로 만듦:
   
   가게 1: Frontend 가게 (5173번 주소)
   - Dockerfile.frontend 읽음
   - "Vue.js 웹사이트를 만드는 가게구나!" 이해함
   - 가게를 만들고 문을 염 ✅
   
   가게 2: Backend 가게 (3001번 주소)
   - Dockerfile.backend 읽음
   - "데이터를 처리하는 가게구나!" 이해함
   - 가게를 만들고 문을 염 ✅
   
   가게 3: Python MCP 가게 (내부)
   - Dockerfile.python 읽음
   - "AI와 대화하는 가게구나!" 이해함
   - 가게를 만들고 문을 염 ✅
   
   가게 4: Python HTTP 가게 (3002번 주소)
   - Dockerfile.python 읽음
   - "화면을 확인하는 가게구나!" 이해함
   - 가게를 만들고 문을 염 ✅

3. 모든 가게가 서로 연결됨
   → Frontend 가게가 Backend 가게와 대화할 수 있게 됨
   → 마치 가게들이 길로 연결된 것처럼!

4. 완료!
   → 이제 웹사이트를 사용할 수 있어요!
```

**비유:**
- `docker-compose up -d` = "프랜차이즈 매뉴얼대로 4개 가게를 모두 열어줘!"
- `-d` = "백그라운드에서 실행" (화면에 안 보이게 조용히 실행)
- 마치 마법처럼 가게들이 자동으로 열리는 것처럼!

**가게를 연 후 확인하기:**

```
1. 웹 UI에서 확인:
   - 웹사이트에 로그인
   - "사용자 관리하기" → "🐳 Docker 상태" 탭 클릭
- "실행 중인 컨테이너 (4개)"가 보일 거예요!
   - 각 가게의 상태를 확인할 수 있어요!

2. 웹 브라우저에서 확인:
   - http://localhost:5173 접속
   - 웹사이트가 정상적으로 열리면 성공!
   - 이게 Frontend 가게가 작동하는 거예요!

3. 터미널에서 확인:
   docker ps
   → 4개의 컨테이너가 보일 거예요!
   → 각 컨테이너의 상태가 "Up"이면 성공!
```

### 컨테이너 중지하기 (가게 닫기) - 실제로 뭘 하나요?

**언제 가게를 닫나요?**
- 컴퓨터를 끄기 전에
- 프로젝트를 사용하지 않을 때
- 문제가 생겨서 다시 시작하고 싶을 때

**가게를 닫는 방법:**

```bash
# 모든 가게를 닫기
docker-compose down
```

**이 명령어를 입력하면 무슨 일이 일어날까요?**

```
실제로 일어나는 일:

1. Docker가 실행 중인 모든 가게를 찾음
   → "아, 4개 가게가 열려있구나!" 확인함

2. 각 가게를 순서대로 닫음:
   - Frontend 가게 문 닫기 ✅
   - Backend 가게 문 닫기 ✅
   - Python MCP 가게 문 닫기 ✅
   - Python HTTP 가게 문 닫기 ✅

3. 가게들을 부숨 (메모리에서 제거)
   → 하지만 설계도(Dockerfile)는 남아있음!
   → 나중에 다시 열 수 있어요!

4. 완료!
   → 이제 가게들이 모두 닫혔어요!
   → 컴퓨터 리소스를 사용하지 않아요!
```

**비유:**
- `docker-compose down` = "모든 가게를 닫고 부숴줘!"
- 설계도(매뉴얼)는 남아있어서 나중에 다시 열 수 있음
- 마치 가게를 닫지만 매뉴얼은 보관하는 것처럼!

**확인 방법:**
```bash
docker ps
# → 아무것도 안 보이면 성공! (가게들이 모두 닫혔어요)
```

### 컨테이너 재시작하기 (가게 다시 열기) - 문제 해결할 때!

**언제 가게를 다시 열나요?**
- 가게에 문제가 생겼을 때
- 설정을 변경했을 때
- 코드를 수정했을 때

**가게를 다시 여는 방법:**

```bash
# 모든 가게를 다시 열기
docker-compose restart
```

**이 명령어를 입력하면 무슨 일이 일어날까요?**

```
실제로 일어나는 일:

1. Docker가 실행 중인 모든 가게를 찾음
   → "아, 4개 가게가 열려있구나!" 확인함

2. 각 가게를 순서대로 닫고 다시 염:
   - Frontend 가게: 닫기 → 다시 열기 ✅
   - Backend 가게: 닫기 → 다시 열기 ✅
   - Python MCP 가게: 닫기 → 다시 열기 ✅
   - Python HTTP 가게: 닫기 → 다시 열기 ✅

3. 빠르게 재시작됨
   → 가게를 완전히 부수지 않고 그냥 다시 시작함
   → 빠르고 간단함!

4. 완료!
   → 이제 가게들이 새롭게 시작되었어요!
   → 문제가 해결되었을 거예요!
```

**비유:**
- `docker-compose restart` = "모든 가게를 닫고 다시 열어줘!"
- 가게를 고칠 때 사용해요!
- 마치 가게에 문제가 생겨서 문을 닫고 다시 여는 것처럼!

**언제 사용하나요?**
- 웹사이트가 이상하게 작동할 때
- 오류가 발생했을 때
- 설정을 변경했을 때

### 로그 확인하기 (가게에서 무슨 일이 일어나는지 보기) - 문제 찾을 때!

**로그가 뭔가요?**
- 가게에서 일어난 모든 일을 기록한 일기장이에요!
- 누가 왔는지, 무슨 일이 일어났는지, 오류가 났는지 모두 기록돼요!

**언제 로그를 확인하나요?**
- 웹사이트가 작동하지 않을 때
- 오류가 발생했을 때
- 가게가 제대로 작동하는지 확인하고 싶을 때

**로그를 확인하는 방법:**

```bash
# 특정 가게의 로그 보기
docker logs test02-frontend
docker logs test02-backend
```

**실제 예시:**
```
docker logs test02-frontend 입력하면:

2025-01-15 10:30:15 - Frontend 가게가 열렸어요! ✅
2025-01-15 10:30:16 - 웹사이트 파일을 불러왔어요!
2025-01-15 10:30:17 - 사용자가 접속했어요!
2025-01-15 10:30:18 - 오류 발생! 파일을 찾을 수 없어요! ❌

→ 이렇게 가게에서 일어난 모든 일을 볼 수 있어요!
→ 오류가 났다면 여기서 확인할 수 있어요!
```

**실시간으로 로그 보기 (계속 업데이트됨):**

```bash
# 실시간으로 로그 보기 (새로운 일이 생기면 바로 보임)
docker logs -f test02-frontend
```

**비유:**
- `docker logs` = "이 가게에서 무슨 일이 일어났는지 일기 보여줘"
- `-f` = "실시간으로 계속 보여줘" (새로운 일이 생기면 바로 보임)
- 마치 가게에서 무슨 일이 일어나는지 실시간으로 보는 것처럼!

**실제 사용 예시:**
```
상황: 웹사이트가 안 열려요!

1. 로그 확인:
   docker logs test02-frontend

2. 로그에서 오류 찾기:
   → "오류: 포트 5173이 이미 사용 중이에요!" 발견!

3. 문제 해결:
   → 다른 프로그램이 포트를 쓰고 있구나!
   → 그 프로그램을 종료하거나 포트를 바꾸면 돼요!

4. 다시 확인:
   docker logs test02-frontend
   → "가게가 정상적으로 열렸어요!" 확인!
```

### 상태 확인하기 (가게가 잘 열렸는지 확인) - 간단하게!

**상태 확인이 뭔가요?**
- 가게들이 제대로 열려있는지 확인하는 거예요!
- 몇 개의 가게가 열려있는지, 각 가게가 잘 작동하는지 확인해요!

**상태를 확인하는 방법:**

```bash
# 실행 중인 가게 목록 보기
docker ps
```

**실제 예시:**
```
docker ps 입력하면:

이름                  상태      포트
test02-frontend      Up        5173:80
test02-backend       Up        3001:3001
test02-python-mcp    Up        (내부)
test02-python-http   Up        3002:3002

→ 4개 가게가 모두 열려있어요! ✅
→ 각 가게의 상태가 "Up"이면 정상이에요!
```

**모든 가게 목록 보기 (닫힌 것도 포함):**

```bash
# 모든 가게 목록 보기 (닫힌 것도 포함)
docker ps -a
```

**비유:**
- `docker ps` = "지금 열려있는 가게 목록 보여줘"
- `docker ps -a` = "열렸던 가게도 포함해서 모든 가게 보여줘"
- 마치 마을의 가게 목록을 보는 것처럼!

**실제 사용 예시:**
```
상황: 가게가 제대로 열렸는지 확인하고 싶어요!

1. 상태 확인:
   docker ps

2. 결과 확인:
   → 4개 가게가 모두 "Up" 상태면 성공! ✅
   → 만약 "Exited" 상태면 가게가 닫혔어요! ❌

3. 문제가 있으면:
   → docker-compose restart로 다시 열어요!
```

### 실제 사용 예시 - 상황별로 완전히 이해하기!

#### 시나리오 1: 처음 시작하기 (처음 사용할 때)

**상황:** 프로젝트를 처음 다운로드받았어요! 어떻게 시작하나요?

**단계별 가이드:**

```bash
# 1단계: 모든 가게 열기
docker-compose up -d

# 이 명령어를 실행하면:
# - Docker가 docker-compose.yml 파일을 읽음
# - 4개 가게를 자동으로 만듦
# - 각 가게를 열고 서로 연결함
# - 시간: 약 5분 소요
```

**실제로 일어나는 일:**
```
1. Docker가 시작됨
   → "프랜차이즈 본사가 준비되었어요!"

2. 각 가게를 순서대로 만듦:
   - Frontend 가게 만들기... ✅
   - Backend 가게 만들기... ✅
   - Python MCP 가게 만들기... ✅
   - Python HTTP 가게 만들기... ✅

3. 모든 가게가 서로 연결됨
   → Frontend ↔ Backend ↔ Python 서버들

4. 완료!
   → "모든 가게가 열렸어요!"
```

```bash
# 2단계: 가게가 잘 열렸는지 확인
docker ps

# 결과 확인:
# → 4개 가게가 모두 "Up" 상태면 성공! ✅
# → 만약 "Exited" 상태면 문제가 있어요! ❌
```

```bash
# 3단계: 웹 브라우저에서 확인
# http://localhost:5173 접속

# 웹사이트가 정상적으로 열리면 성공! ✅
# 웹사이트가 안 열리면 로그를 확인해요!
```

**예상 결과:**
- 웹사이트가 정상적으로 열림 ✅
- 4개 가게가 모두 실행 중 ✅
- 모든 기능이 정상 작동 ✅

---

#### 시나리오 2: 가게 고치기 (문제가 생겼을 때)

**상황:** 웹사이트가 이상하게 작동해요! 어떻게 고치나요?

**단계별 가이드:**

```bash
# 1단계: 모든 가게 다시 열기
docker-compose restart

# 이 명령어를 실행하면:
# - 모든 가게를 닫고 다시 염
# - 빠르게 재시작됨
# - 시간: 약 1분 소요
```

**실제로 일어나는 일:**
```
1. Docker가 실행 중인 모든 가게를 찾음
   → "4개 가게가 열려있구나!"

2. 각 가게를 순서대로 재시작:
   - Frontend 가게: 닫기 → 다시 열기 ✅
   - Backend 가게: 닫기 → 다시 열기 ✅
   - Python MCP 가게: 닫기 → 다시 열기 ✅
   - Python HTTP 가게: 닫기 → 다시 열기 ✅

3. 완료!
   → "모든 가게가 새롭게 시작되었어요!"
```

```bash
# 2단계: 로그 확인해서 문제 없는지 보기
docker logs test02-frontend

# 로그에서 확인할 것:
# → "가게가 정상적으로 열렸어요!" 메시지 확인 ✅
# → 오류 메시지가 없으면 성공! ✅
# → 오류 메시지가 있으면 문제를 해결해야 해요! ❌
```

**예상 결과:**
- 가게들이 새롭게 시작됨 ✅
- 웹사이트가 정상적으로 작동함 ✅
- 문제가 해결됨 ✅

**만약 문제가 계속되면:**
```bash
# 완전히 닫고 다시 열기
docker-compose down
docker-compose up -d
```

---

#### 시나리오 3: 가게 닫기 (사용하지 않을 때)

**상황:** 프로젝트를 사용하지 않을 거예요! 어떻게 닫나요?

**단계별 가이드:**

```bash
# 1단계: 모든 가게 닫기
docker-compose down

# 이 명령어를 실행하면:
# - 모든 가게를 닫음
# - 가게들을 메모리에서 제거함
# - 하지만 설계도(매뉴얼)는 남아있음
# - 시간: 약 10초 소요
```

**실제로 일어나는 일:**
```
1. Docker가 실행 중인 모든 가게를 찾음
   → "4개 가게가 열려있구나!"

2. 각 가게를 순서대로 닫음:
   - Frontend 가게 문 닫기 ✅
   - Backend 가게 문 닫기 ✅
   - Python MCP 가게 문 닫기 ✅
   - Python HTTP 가게 문 닫기 ✅

3. 가게들을 메모리에서 제거함
   → 하지만 설계도(Dockerfile)는 남아있음!
   → 나중에 다시 열 수 있어요!

4. 완료!
   → "모든 가게가 닫혔어요!"
   → 컴퓨터 리소스를 사용하지 않아요!
```

```bash
# 2단계: 확인
docker ps

# 결과 확인:
# → 아무것도 안 보이면 성공! (가게들이 모두 닫혔어요) ✅
```

**예상 결과:**
- 모든 가게가 닫혔어요 ✅
- 컴퓨터 리소스를 사용하지 않아요 ✅
- 나중에 다시 열 수 있어요 ✅

**다시 사용하고 싶을 때:**
```bash
# 다시 열기
docker-compose up -d
```

---

## ❓ 자주 묻는 질문 (FAQ)

### Q1: Docker Desktop에 로그인해야 하나요?

**답변: 아니요! 로그인 없이도 사용할 수 있어요!**

**비유로 설명하면:**
- 레고 상자를 사용할 때 계정에 로그인할 필요 없어요!
- 로컬에서 레고 집을 지을 때는 로그인 필요 없어요!
- 하지만 인터넷에서 레고를 다운로드하려면 로그인이 필요할 수 있어요!

**언제 로그인이 필요한가요?**

1. **로그인 필요 없음 (대부분의 경우):**
   - 로컬에서 컨테이너 실행
   - 프로젝트 빌드 및 실행
   - `docker-compose up -d` 명령어 사용
   - 이 프로젝트의 모든 기능 사용

2. **로그인이 필요한 경우:**
   - Docker Hub에서 공개 이미지 다운로드 (대부분은 로그인 없이 가능)
   - Docker Hub에 이미지 업로드
   - 프라이빗 이미지 다운로드

**결론:**
- **이 프로젝트를 사용할 때는 로그인 필요 없어요!**
- Docker Desktop만 실행하면 바로 사용할 수 있어요!
- 마치 레고 상자를 열면 바로 사용할 수 있는 것처럼!

### Q2: Docker Desktop을 실행했는데도 오류가 나요

**가능한 원인:**
1. Docker Desktop이 완전히 시작되지 않았을 수 있어요
   - 해결: 1-2분 더 기다리기
2. Docker Desktop이 백그라운드에서 실행 중일 수 있어요
   - 해결: 시스템 트레이에서 고래 아이콘 확인

### Q3: Docker Desktop을 다시 실행한 후 뭘 해야 하나요?

**단계별 가이드:**

**1단계: Docker Desktop이 완전히 시작되었는지 확인**
- 시스템 트레이(화면 오른쪽 아래)에 고래 아이콘(🐳) 확인
- 고래 아이콘이 멈추면 준비 완료!
- 고래 아이콘이 움직이면 아직 시작 중이에요 (1-2분 더 기다리기)

**2단계: Docker가 작동하는지 확인**
```bash
docker ps
```
- 오류가 안 나면 성공!
- 빈 목록이 나와도 정상이에요 (아직 컨테이너를 시작하지 않았으니까요)

**3단계: 컨테이너 시작하기 (레고 집 짓기)**
```bash
docker-compose up -d
```
- 이 명령어로 모든 컨테이너를 시작해요
- 4개의 집이 자동으로 지어져요!

**4단계: 컨테이너가 잘 시작되었는지 확인**
```bash
docker ps
```
- 이제 4개의 컨테이너가 보일 거예요!
- 각 컨테이너의 상태가 "Up"이면 성공!

**5단계: 웹 브라우저에서 확인**
- http://localhost:5173 접속
- 웹사이트가 정상적으로 열리면 성공!

**6단계: 웹 UI에서 Docker 상태 확인**
- 웹사이트에 로그인
- "사용자 관리하기" → "🐳 Docker 상태" 탭 클릭
- "실행 중인 컨테이너 (4개)"가 보일 거예요!

**비유로 정리:**
1. Docker Desktop 실행 = 레고 상자 열기
2. `docker ps` = 집 목록 확인 (아직 없음)
3. `docker-compose up -d` = 집 짓기 시작!
4. `docker ps` = 집 목록 확인 (4개 집이 지어짐!)
5. 웹사이트 접속 = 집에 들어가서 확인!

### Q4: "WSL needs updating" 오류가 나요

**오류 메시지:**
```
WSL needs updating
Your version of Windows Subsystem for Linux (WSL) is too old.
```

**이게 무슨 뜻일까요?**

**비유로 설명하면:**
- Docker Desktop은 WSL(Windows Subsystem for Linux)이라는 도구를 사용해요
- 마치 레고 집을 지을 때 리눅스라는 도구가 필요한데, 그 도구가 오래되어서 업데이트가 필요해요!

**WSL이 뭔가요?**
- Windows에서 리눅스 프로그램을 실행할 수 있게 해주는 도구예요
- Docker Desktop이 리눅스 환경에서 작동하기 때문에 필요해요
- 마치 레고 집을 지을 때 특별한 도구가 필요한 것처럼!

**해결 방법:**

**방법 1: 자동 업데이트 (가장 쉬운 방법)**

1. **PowerShell을 관리자 권한으로 실행**
   - Windows 시작 메뉴에서 "PowerShell" 검색
   - 오른쪽 클릭 → "관리자 권한으로 실행" 선택

2. **업데이트 명령어 실행**
   ```powershell
   wsl --update
   ```
   - 이 명령어를 입력하고 Enter 키 누르기
   - 업데이트가 자동으로 진행돼요!

3. **WSL 재시작**
   ```powershell
   wsl --shutdown
   ```
   - 업데이트 후 재시작이 필요해요

4. **Docker Desktop 다시 실행**
   - Docker Desktop을 종료하고 다시 실행
   - 이제 정상적으로 작동할 거예요!

**방법 2: 수동 업데이트 (방법 1이 안 될 때)**

1. **Microsoft Store에서 업데이트**
   - Microsoft Store 열기
   - "Windows Subsystem for Linux" 검색
   - 업데이트 버튼 클릭

2. **또는 Microsoft 웹사이트에서 다운로드**
   - https://aka.ms/wsl2kernel 접속
   - WSL2 커널 업데이트 패키지 다운로드 및 설치

**확인 방법:**
```powershell
wsl --version
```
- 이 명령어로 WSL 버전을 확인할 수 있어요
- 버전이 2.0 이상이면 최신 버전이에요!

**비유로 정리:**
- WSL = 레고 집을 지을 때 필요한 특별한 도구
- 오래된 도구 = 오래된 WSL 버전
- 업데이트 = 도구를 새 것으로 교체
- 새 도구로 레고 집을 지을 수 있어요!

### Q5: "Virtualization support not detected" 오류가 나요

**오류 메시지:**
```
Virtualization support not detected
Docker Desktop failed to start because virtualisation support wasn't detected.
```

**이게 무슨 뜻일까요?**

**비유로 설명하면:**
- Docker Desktop은 가상화 기능을 사용해서 가게(컨테이너)를 만들어요
- 마치 레고 집을 지을 때 특별한 도구(가상화)가 필요한데, 그 도구가 꺼져있어요!
- 컴퓨터의 가상화 기능이 비활성화되어 있어서 Docker가 작동하지 않아요!

**가장 쉬운 해결 방법:**

**1단계: Windows 기능에서 가상화 활성화하기**

1. **Windows 시작 메뉴에서 "Windows 기능 켜기/끄기" 검색**
2. **다음 항목들을 모두 체크하세요:**
   - ✅ Windows 하이퍼바이저 플랫폼
   - ✅ 가상 머신 플랫폼
   - ✅ WSL (Windows Subsystem for Linux) - **이게 없다면 아래 방법으로 설치하세요!**
3. **"확인" 버튼 클릭하고 컴퓨터 재시작**
4. **Docker Desktop 다시 실행**

**⚠️ 중요: WSL이 Windows 기능에 없다면?**

**WSL이 Windows 기능 켜기/끄기에 보이지 않는 경우:**
- Windows 10 Home 버전을 사용 중일 수 있어요
- 또는 Windows 버전이 오래되었을 수 있어요
- 이 경우 PowerShell 명령어로 설치해야 해요!

**해결 방법: PowerShell로 WSL 설치하기**

**방법 1: PowerShell 명령어로 설치 (가장 쉬운 방법)**

1. **PowerShell을 관리자 권한으로 실행**
   - Windows 시작 메뉴에서 "PowerShell" 검색
   - 오른쪽 클릭 → "관리자 권한으로 실행" 선택

2. **WSL 설치 명령어 실행**
   ```powershell
   wsl --install
   ```
   - 이 명령어를 입력하고 Enter 키 누르기
   - WSL과 필요한 기능들이 자동으로 설치돼요!
   - 시간: 약 5-10분 소요

3. **컴퓨터 재시작**
   - 설치가 완료되면 컴퓨터를 재시작해야 해요!
   - 재시작 후 WSL이 설치되었어요!

**방법 2: 수동으로 설치하기 (방법 1이 안 될 때)**

1. **PowerShell을 관리자 권한으로 실행**

2. **다음 명령어들을 순서대로 실행:**
   ```powershell
   # WSL 기능 활성화
   dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
   
   # 가상 머신 플랫폼 활성화
   dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
   ```

3. **컴퓨터 재시작**

4. **WSL 2 커널 업데이트 패키지 다운로드 및 설치**
   - https://aka.ms/wsl2kernel 접속
   - "WSL2 Linux 커널 업데이트 패키지" 다운로드
   - 다운로드한 파일 실행하여 설치

5. **WSL 2를 기본 버전으로 설정**
   ```powershell
   wsl --set-default-version 2
   ```

**확인 방법:**
```powershell
wsl --status
```
- "기본 버전: 2"라고 나오면 성공! ✅

**2단계: 가상화가 활성화되었는지 확인하기**

**작업 관리자에서 확인:**
1. `Ctrl + Shift + Esc` 키를 눌러 작업 관리자 열기
2. "성능" 탭 클릭
3. "CPU" 선택
4. 오른쪽 아래에서 "가상화" 확인
5. "사용"이라고 나오면 성공! ✅

**만약 "사용 안 함"이라고 나오면:**
- BIOS/UEFI에서 가상화를 활성화해야 해요
- 자세한 내용은 [문제 해결 섹션](#문제-virtualization-support-not-detected-오류)을 참고하세요!

**비유로 정리:**
- 가상화 = 레고 집을 지을 때 필요한 특별한 도구
- 도구가 꺼져있음 = 가상화 기능이 비활성화됨
- 도구를 켜기 = Windows 기능에서 가상화 활성화
- 도구를 켜면 레고 집을 지을 수 있어요!

---

## ⚠️ 문제 해결 (초등학생도 이해하는 설명)

### 문제: "The system cannot find the file specified" 오류

**터미널에 이런 오류가 나왔나요?**
```
error during connect: Get "http://...": open //./pipe/dockerDesktopLinuxEngine: The system cannot find the file specified.
```

**이게 무슨 뜻일까요?**

**비유로 설명하면:**
- 레고 상자는 있지만, 레고 상자를 여는 열쇠가 없어요!
- Docker는 설치되어 있지만, Docker를 실행하는 프로그램(Docker Desktop)이 꺼져있어요!

**해결 방법:**

1. **Docker Desktop 실행하기**
   - Windows 시작 메뉴에서 "Docker Desktop" 검색
   - Docker Desktop 프로그램 실행
   - 시스템 트레이(화면 오른쪽 아래)에 고래 아이콘(🐳)이 나타나면 성공!

2. **Docker Desktop이 시작될 때까지 기다리기**
   - Docker Desktop을 처음 실행하면 시간이 걸려요 (1-2분)
   - 고래 아이콘이 움직이면 아직 시작 중이에요
   - 고래 아이콘이 멈추면 준비 완료!

3. **다시 명령어 실행하기**
   ```bash
   docker ps
   ```
   - 오류가 안 나면 성공!
   - 오류가 나면 Docker Desktop이 완전히 시작될 때까지 조금 더 기다리세요

**확인 방법:**
- 시스템 트레이(화면 오른쪽 아래)에 고래 아이콘(🐳)이 있는지 확인
- 고래 아이콘을 클릭하면 Docker Desktop 창이 열려요
- "Docker Desktop is running"이라고 나오면 정상!

**비유:**
- Docker Desktop = 레고 상자를 여는 열쇠
- 열쇠 없이는 레고 상자를 열 수 없어요!
- 열쇠를 먼저 켜야(실행해야) 레고 집을 지을 수 있어요!

---

### 문제: "Virtualization support not detected" 오류

**Docker Desktop에서 이런 오류가 나왔나요?**
```
Virtualization support not detected
Docker Desktop failed to start because virtualisation support wasn't detected.
```

**이게 무슨 뜻일까요?**

**비유로 설명하면:**
- Docker Desktop은 가상화 기능을 사용해서 가게(컨테이너)를 만들어요
- 마치 레고 집을 지을 때 특별한 도구(가상화)가 필요한데, 그 도구가 꺼져있어요!
- 컴퓨터의 가상화 기능이 비활성화되어 있어서 Docker가 작동하지 않아요!

**가상화가 뭔가요?**
- 가상화는 컴퓨터 안에 또 다른 작은 컴퓨터를 만드는 기능이에요
- Docker는 이 기능을 사용해서 컨테이너를 만들어요
- Windows에서는 Hyper-V 또는 WSL 2가 이 기능을 제공해요

**해결 방법 - 단계별로 완전히 이해하기!**

#### 방법 1: Windows 기능에서 가상화 활성화하기 (가장 일반적인 해결책)

**1단계: Windows 기능 켜기/끄기 열기**

```
1. Windows 시작 메뉴에서 "Windows 기능 켜기/끄기" 검색
2. 또는 "제어판" → "프로그램" → "Windows 기능 켜기/끄기"
3. 관리자 권한이 필요할 수 있어요!
```

**2단계: 필요한 기능들 활성화하기**

다음 항목들을 모두 체크하세요:

```
✅ Windows 하이퍼바이저 플랫폼
✅ 가상 머신 플랫폼
✅ WSL (Windows Subsystem for Linux) - 없으면 아래 방법으로 설치하세요!
```

**⚠️ WSL이 보이지 않는다면?**

**WSL이 Windows 기능 켜기/끄기에 없다면 PowerShell로 설치해야 해요!**

**PowerShell을 관리자 권한으로 실행한 후:**
```powershell
wsl --install
```

이 명령어 하나로 WSL과 필요한 모든 기능이 자동으로 설치돼요!
- 시간: 약 5-10분 소요
- 설치 후 컴퓨터 재시작 필요

**실제 화면에서 확인할 것:**
- 각 항목 옆에 체크박스가 있어요
- 체크박스를 클릭해서 ✅ 표시를 만들어요
- "확인" 버튼을 클릭하면 Windows가 필요한 파일을 설치해요
- WSL이 없다면 PowerShell로 먼저 설치한 후 다시 확인해요!

**3단계: 컴퓨터 재시작하기**

```
- Windows 기능을 변경했으므로 컴퓨터를 재시작해야 해요!
- 재시작 후 Docker Desktop을 다시 실행해보세요!
```

**4단계: Docker Desktop 다시 실행하기**

```
1. Docker Desktop 실행
2. 오류가 사라졌는지 확인
3. 정상적으로 시작되면 성공! ✅
```

#### 방법 2: BIOS/UEFI에서 가상화 활성화하기 (방법 1이 안 될 때)

**이게 무슨 뜻일까요?**
- BIOS/UEFI는 컴퓨터의 가장 기본적인 설정이에요
- 컴퓨터를 켤 때 가장 먼저 실행되는 프로그램이에요
- 여기서 가상화 기능을 켜야 해요!

**1단계: BIOS/UEFI 진입하기**

```
1. 컴퓨터를 재시작하세요
2. 컴퓨터가 켜지는 순간 특정 키를 누르세요:
   - 보통 F2, F10, F12, Delete 키 중 하나예요
   - 컴퓨터 제조사마다 다를 수 있어요
   - 화면에 "Press F2 to enter Setup" 같은 메시지가 보일 거예요
```

**2단계: 가상화 설정 찾기**

BIOS/UEFI 화면에서 다음 중 하나를 찾으세요:

```
- Virtualization Technology (VT-x) - Intel CPU인 경우
- AMD-V - AMD CPU인 경우
- Virtualization
- Intel Virtualization Technology
- SVM Mode (AMD CPU인 경우)
```

**3단계: 가상화 기능 활성화하기**

```
1. 찾은 항목을 선택하세요
2. "Enabled" 또는 "Enabled"로 변경하세요
3. 설정을 저장하고 나가세요 (보통 F10 키)
```

**4단계: 컴퓨터 재시작하기**

```
- BIOS/UEFI 설정을 변경했으므로 컴퓨터를 재시작해야 해요!
- 재시작 후 Docker Desktop을 다시 실행해보세요!
```

#### 방법 3: 가상화가 활성화되었는지 확인하기

**PowerShell에서 확인하기:**

```powershell
# PowerShell을 관리자 권한으로 실행한 후:
systeminfo | findstr /C:"Hyper-V"
```

**결과 확인:**
```
- "Hyper-V 요구 사항" 섹션에서 확인
- "가상화가 펌웨어에 사용 설정됨: 예" 라고 나오면 성공! ✅
- "가상화가 펌웨어에 사용 설정됨: 아니오" 라고 나오면 BIOS에서 활성화해야 해요! ❌
```

**또는 작업 관리자에서 확인하기:**

```
1. Ctrl + Shift + Esc 키를 눌러 작업 관리자 열기
2. "성능" 탭 클릭
3. "CPU" 선택
4. 오른쪽 아래에서 "가상화" 확인
5. "사용"이라고 나오면 성공! ✅
6. "사용 안 함"이라고 나오면 BIOS에서 활성화해야 해요! ❌
```

#### 방법 4: WSL 2로 전환하기 (Windows 11/10 권장)

**WSL 2가 뭔가요?**
- Windows Subsystem for Linux 2의 약자예요
- Docker Desktop이 WSL 2를 사용하면 더 빠르고 안정적이에요!

**WSL 2로 전환하기:**

```powershell
# PowerShell을 관리자 권한으로 실행한 후:
wsl --set-default-version 2
```

**WSL 2가 설치되어 있지 않다면:**

```powershell
# PowerShell을 관리자 권한으로 실행한 후:
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
```

**확인하기:**

```powershell
wsl --status
```

**결과 확인:**
```
- "기본 버전: 2"라고 나오면 성공! ✅
- "기본 버전: 1"이라고 나오면 WSL 2로 업그레이드해야 해요!
```

**비유로 정리:**
- 가상화 = 레고 집을 지을 때 필요한 특별한 도구
- 도구가 꺼져있음 = 가상화 기능이 비활성화됨
- 도구를 켜기 = Windows 기능에서 가상화 활성화
- BIOS에서 켜기 = 컴퓨터의 가장 기본적인 설정에서 활성화
- 도구를 켜면 레고 집을 지을 수 있어요!

**추가 팁:**
- 노트북을 사용 중이라면 전원 설정을 "고성능" 모드로 변경해보세요
- 일부 노트북은 배터리 모드에서 가상화가 비활성화될 수 있어요
- Windows 업데이트를 최신 버전으로 유지하세요

---

## 📝 상세 구현 내역

### 1. Frontend Dockerfile

**역할:**
- Vue.js 애플리케이션을 빌드하고 Nginx로 서빙

**빌드 과정:**
1. Node.js 20 이미지로 빌드 스테이지 시작
2. `package.json` 복사 및 의존성 설치
3. 소스 코드 복사 및 빌드 (`npm run build`)
4. Nginx 이미지로 프로덕션 스테이지 시작
5. 빌드된 파일을 Nginx에 복사
6. Nginx 설정 파일 복사
7. 포트 80 노출

**최적화:**
- 멀티 스테이지 빌드로 최종 이미지 크기 최소화
- 빌드 도구는 최종 이미지에 포함되지 않음

### 2. Backend Dockerfile

**역할:**
- Node.js API 서버 실행

**빌드 과정:**
1. Node.js 20 Alpine 이미지 사용 (경량)
2. `package.json` 복사 및 프로덕션 의존성만 설치
3. 소스 코드 복사 (`api-server.js`, `database.js`, `swagger.json`)
4. ✅ MCP 서버 파일 복사 (`mcp-server.js`) - API 서버에서 import하여 사용
5. 데이터 디렉토리 생성
6. 포트 3001 노출
7. 헬스체크 설정 (`/api-docs` 엔드포인트 확인)

**특징:**
- Alpine Linux 사용으로 이미지 크기 최소화
- 프로덕션 의존성만 설치 (`--only=production`)
- ✅ MCP 서버 통합: 뉴스 검색 등 주요 기능을 MCP 서버를 통해 제공

### 3. Python Dockerfile

**역할:**
- Python MCP 서버 및 HTTP 서버 실행

**빌드 과정:**
1. Python 3.11 Slim 이미지 사용
2. 시스템 패키지 설치 (wget, gnupg)
3. `requirements.txt` 복사 및 Python 패키지 설치
4. Playwright 브라우저 설치 (Chromium)
5. ✅ 모든 Python MCP 서버 파일 복사:
   - `mcp-unified-server.py` (도서 추천, 계산기)
   - `mcp-error-log-analyzer.py` (에러 로그 분석)
   - `mcp-sql-query-analyzer.py` (SQL 쿼리 분석)
   - `mcp-impact-analyzer.py` (영향도 분석)
   - `mcp-screen-validator-http-server.py` (화면 검증)
   - `mcp-book-server.py`, `mcp-add-server.py` (기타 서버)
6. 포트 3002 노출

**특징:**
- Playwright 브라우저 포함 (화면 검증 기능용)
- Slim 이미지 사용으로 크기 최적화
- ✅ 모든 Python MCP 서버 포함: 에러 로그, SQL 쿼리, 영향도 분석 등

### 4. Docker Compose 설정

**프로덕션 환경 (`docker-compose.yml`):**
- 4개 서비스 정의
- 네트워크: `test02-network` (bridge)
- 볼륨: `./data:/app/data` (데이터 영구 저장)
- 헬스체크: 각 서비스별 상태 확인
- 재시작 정책: `unless-stopped` (자동 재시작)

**개발 환경 (`docker-compose.dev.yml`):**
- 2개 서비스만 (Frontend, Backend)
- 볼륨 마운트로 코드 변경 시 자동 반영
- 핫 리로드 및 자동 재시작 활성화

### 5. 빌드 스크립트

**기능:**
- Docker 설치 확인
- Docker Compose 버전 확인 (v1/v2)
- 빌드 모드 선택 (프로덕션/개발)
- 빌드 실행 및 결과 출력

---

## 🔍 Docker 상태 확인 API

### API 엔드포인트

**`GET /api/docker/status`**

**응답 형식:**
```json
{
  "success": true,
  "docker": {
    "installed": true,
    "running": true,
    "version": "24.0.0"
  },
  "containers": [
    {
      "name": "test02-frontend",
      "status": "running",
      "image": "test02-frontend:latest",
      "ports": ["5173:80"],
      "uptime": "2h 30m",
      "cpu": "0.5%",
      "memory": "45MB"
    },
    {
      "name": "test02-backend",
      "status": "running",
      "image": "test02-backend:latest",
      "ports": ["3001:3001"],
      "uptime": "2h 30m",
      "cpu": "1.2%",
      "memory": "120MB"
    }
  ]
}
```

---

## 📚 참고 자료

- **Docker 공식 문서**: https://docs.docker.com
- **Docker Compose 문서**: https://docs.docker.com/compose
- **프로젝트 Docker 가이드**: [`Docker_빌드_배포_가이드.md`](./Docker_빌드_배포_가이드.md)
- **Docker 최적화 가이드**: [`Docker_빌드_최적화_가이드.md`](./Docker_빌드_최적화_가이드.md)

---

**마지막 업데이트**: 2025년 1월

